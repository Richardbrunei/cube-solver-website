<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOM Optimization Test</title>
    <link rel="stylesheet" href="../styles/animation.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        
        h1 {
            color: #4CAF50;
        }
        
        .test-section {
            background: #2a2a2a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .test-result.pass {
            background: #2d5016;
            border-left: 4px solid #4CAF50;
        }
        
        .test-result.fail {
            background: #5d1616;
            border-left: 4px solid #f44336;
        }
        
        .test-result.info {
            background: #1a3a5d;
            border-left: 4px solid #2196F3;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <h1>ðŸ§ª DOM Optimization Test</h1>
    <p>This test verifies that AnimationController reuses DOM elements instead of recreating them.</p>
    
    <div class="test-section">
        <h2>Test 1: DOM Element Reuse</h2>
        <p>Verifies that cube structure is created once and reused for subsequent renders</p>
        <button id="test-reuse-btn">Test DOM Reuse</button>
        <div id="test-reuse-results"></div>
    </div>
    
    <div class="test-section">
        <h2>Test 2: CSS Class-Based Updates</h2>
        <p>Verifies that color changes use CSS classes instead of inline styles</p>
        <button id="test-classes-btn">Test CSS Classes</button>
        <div id="test-classes-results"></div>
    </div>
    
    <div class="test-section">
        <h2>Test 3: Batched Updates</h2>
        <p>Verifies that DOM updates are batched to minimize reflows</p>
        <button id="test-batch-btn">Test Batched Updates</button>
        <div id="test-batch-results"></div>
    </div>
    
    <div class="test-section">
        <h2>Test 4: Cached References</h2>
        <p>Verifies that DOM element references are cached in constructor</p>
        <button id="test-cache-btn">Test Cached References</button>
        <div id="test-cache-results"></div>
    </div>

    <script type="module">
        import { AnimationController } from '../scripts/animation-controller.js';
        
        // Test 1: DOM Element Reuse
        document.getElementById('test-reuse-btn').addEventListener('click', async () => {
            const resultsDiv = document.getElementById('test-reuse-results');
            resultsDiv.innerHTML = '<div class="test-result info">Testing DOM element reuse...</div>';
            
            try {
                const controller = new AnimationController();
                
                // Create a test cubestring
                const testCubestring = 'UUUUUUUUURRRRRRRRRFFFFFFFFFDDDDDDDDDLLLLLLLLLBBBBBBBBB';
                
                // Start animation to create modal
                const testMoves = ['R', 'U', "R'"];
                controller.startAnimation(testMoves, testCubestring);
                
                // Wait for modal to be created
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Get initial cube wrapper and stickers
                const cubeWrapper1 = controller.cachedCubeWrapper;
                const stickers1 = controller.cachedStickers;
                
                if (!cubeWrapper1 || !stickers1) {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— Cached elements not created</div>';
                    controller.close();
                    return;
                }
                
                resultsDiv.innerHTML += '<div class="test-result pass">âœ“ Initial cube structure created</div>';
                resultsDiv.innerHTML += `<div class="test-result info">Cached stickers: ${stickers1.length}</div>`;
                
                // Trigger a re-render by stepping forward
                controller.stepForward();
                
                // Wait for render
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Get cube wrapper and stickers after re-render
                const cubeWrapper2 = controller.cachedCubeWrapper;
                const stickers2 = controller.cachedStickers;
                
                // Verify same references (DOM reuse)
                if (cubeWrapper1 === cubeWrapper2) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ Cube wrapper reused (same reference)</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— Cube wrapper recreated (different reference)</div>';
                }
                
                if (stickers1 === stickers2) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ Sticker array reused (same reference)</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— Sticker array recreated (different reference)</div>';
                }
                
                // Verify individual sticker elements are the same
                let stickerReuseCount = 0;
                for (let i = 0; i < 54; i++) {
                    if (stickers1[i] === stickers2[i]) {
                        stickerReuseCount++;
                    }
                }
                
                if (stickerReuseCount === 54) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ All 54 sticker elements reused</div>';
                } else {
                    resultsDiv.innerHTML += `<div class="test-result fail">âœ— Only ${stickerReuseCount}/54 stickers reused</div>`;
                }
                
                controller.close();
                
            } catch (error) {
                resultsDiv.innerHTML += `
                    <div class="test-result fail">âœ— DOM reuse test failed</div>
                    <div class="test-result fail">Error: ${error.message}</div>
                `;
            }
        });
        
        // Test 2: CSS Class-Based Updates
        document.getElementById('test-classes-btn').addEventListener('click', async () => {
            const resultsDiv = document.getElementById('test-classes-results');
            resultsDiv.innerHTML = '<div class="test-result info">Testing CSS class-based updates...</div>';
            
            try {
                const controller = new AnimationController();
                
                // Create a test cubestring with different colors
                const testCubestring = 'UUUUUUUUURRRRRRRRRFFFFFFFFFDDDDDDDDDLLLLLLLLLBBBBBBBBB';
                
                // Start animation
                const testMoves = ['R'];
                controller.startAnimation(testMoves, testCubestring);
                
                // Wait for modal to be created
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Check if stickers have color classes
                const stickers = controller.cachedStickers;
                
                if (!stickers || stickers.length !== 54) {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— Stickers not properly cached</div>';
                    controller.close();
                    return;
                }
                
                resultsDiv.innerHTML += '<div class="test-result pass">âœ“ Stickers cached correctly</div>';
                
                // Check if stickers have color classes
                let classBasedCount = 0;
                let inlineStyleCount = 0;
                
                for (let i = 0; i < 54; i++) {
                    const sticker = stickers[i];
                    const hasColorClass = sticker.classList.contains('color-U') ||
                                         sticker.classList.contains('color-R') ||
                                         sticker.classList.contains('color-F') ||
                                         sticker.classList.contains('color-D') ||
                                         sticker.classList.contains('color-L') ||
                                         sticker.classList.contains('color-B');
                    
                    if (hasColorClass) {
                        classBasedCount++;
                    }
                    
                    if (sticker.style.backgroundColor) {
                        inlineStyleCount++;
                    }
                }
                
                resultsDiv.innerHTML += `<div class="test-result info">Stickers with color classes: ${classBasedCount}/54</div>`;
                resultsDiv.innerHTML += `<div class="test-result info">Stickers with inline styles: ${inlineStyleCount}/54</div>`;
                
                if (classBasedCount === 54) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ All stickers use CSS classes</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— Not all stickers use CSS classes</div>';
                }
                
                // Inline styles are OK as fallback, but classes should be primary
                if (inlineStyleCount === 54) {
                    resultsDiv.innerHTML += '<div class="test-result info">â„¹ Inline styles present as fallback (acceptable)</div>';
                }
                
                controller.close();
                
            } catch (error) {
                resultsDiv.innerHTML += `
                    <div class="test-result fail">âœ— CSS class test failed</div>
                    <div class="test-result fail">Error: ${error.message}</div>
                `;
            }
        });
        
        // Test 3: Batched Updates
        document.getElementById('test-batch-btn').addEventListener('click', async () => {
            const resultsDiv = document.getElementById('test-batch-results');
            resultsDiv.innerHTML = '<div class="test-result info">Testing batched updates...</div>';
            
            try {
                const controller = new AnimationController();
                
                // Create a test cubestring
                const testCubestring = 'UUUUUUUUURRRRRRRRRFFFFFFFFFDDDDDDDDDLLLLLLLLLBBBBBBBBB';
                
                // Start animation
                const testMoves = ['R', 'U', 'R\'', 'U\''];
                controller.startAnimation(testMoves, testCubestring);
                
                // Wait for modal to be created
                await new Promise(resolve => setTimeout(resolve, 100));
                
                resultsDiv.innerHTML += '<div class="test-result pass">âœ“ Animation started</div>';
                
                // Measure performance of multiple updates
                const startTime = performance.now();
                
                // Perform multiple steps
                for (let i = 0; i < 4; i++) {
                    controller.stepForward();
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                const endTime = performance.now();
                const totalTime = (endTime - startTime).toFixed(2);
                
                resultsDiv.innerHTML += `<div class="test-result info">4 updates completed in ${totalTime}ms</div>`;
                
                // Check if updates were reasonably fast (should be < 1000ms for 4 updates)
                if (totalTime < 1000) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ Updates are performant (batched)</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— Updates are slow (may not be batched)</div>';
                }
                
                controller.close();
                
            } catch (error) {
                resultsDiv.innerHTML += `
                    <div class="test-result fail">âœ— Batched updates test failed</div>
                    <div class="test-result fail">Error: ${error.message}</div>
                `;
            }
        });
        
        // Test 4: Cached References
        document.getElementById('test-cache-btn').addEventListener('click', async () => {
            const resultsDiv = document.getElementById('test-cache-results');
            resultsDiv.innerHTML = '<div class="test-result info">Testing cached references...</div>';
            
            try {
                const controller = new AnimationController();
                
                // Check if cache properties exist in constructor
                if ('cachedCubeWrapper' in controller) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ cachedCubeWrapper property exists</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— cachedCubeWrapper property missing</div>';
                }
                
                if ('cachedStickers' in controller) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ cachedStickers property exists</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— cachedStickers property missing</div>';
                }
                
                // Initially should be null
                if (controller.cachedCubeWrapper === null) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ cachedCubeWrapper initially null</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— cachedCubeWrapper not initially null</div>';
                }
                
                if (controller.cachedStickers === null) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ cachedStickers initially null</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— cachedStickers not initially null</div>';
                }
                
                // Create animation
                const testCubestring = 'UUUUUUUUURRRRRRRRRFFFFFFFFFDDDDDDDDDLLLLLLLLLBBBBBBBBB';
                const testMoves = ['R'];
                controller.startAnimation(testMoves, testCubestring);
                
                // Wait for modal to be created
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // After rendering, should be populated
                if (controller.cachedCubeWrapper !== null) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ cachedCubeWrapper populated after render</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— cachedCubeWrapper not populated</div>';
                }
                
                if (controller.cachedStickers !== null && controller.cachedStickers.length === 54) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ cachedStickers populated with 54 elements</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— cachedStickers not properly populated</div>';
                }
                
                // Close and verify cleanup
                controller.close();
                
                // Wait for cleanup
                await new Promise(resolve => setTimeout(resolve, 100));
                
                if (controller.cachedCubeWrapper === null) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ cachedCubeWrapper cleared on close</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— cachedCubeWrapper not cleared on close</div>';
                }
                
                if (controller.cachedStickers === null) {
                    resultsDiv.innerHTML += '<div class="test-result pass">âœ“ cachedStickers cleared on close</div>';
                } else {
                    resultsDiv.innerHTML += '<div class="test-result fail">âœ— cachedStickers not cleared on close</div>';
                }
                
            } catch (error) {
                resultsDiv.innerHTML += `
                    <div class="test-result fail">âœ— Cached references test failed</div>
                    <div class="test-result fail">Error: ${error.message}</div>
                `;
            }
        });
        
        console.log('DOM Optimization Test loaded');
    </script>
</body>
</html>
